# 数据结构简介

## **数组（Array）**

数组是一种线性数据结构，它使用**连续的内存空间**存储**相同类型**的元素，并通过索引（下标）访问元素。数组的特点：

- **随机访问**：通过索引可以直接访问任意元素，时间复杂度为 O(1)。
- **固定大小**：一般初始化时需指定大小，不能动态扩展（除非使用动态数组）。
- **插入和删除**：需要移动元素，时间复杂度最差情况为 O(n)。

### **适用场景**

- 需要频繁随机访问的场景，如数据库缓存、二维表存储等。

------

## **栈（Stack）**

栈是一种**后进先出（LIFO, Last In First Out）**的数据结构，只允许在**一端（栈顶）**进行插入和删除操作。

### **栈的操作**

- **push**(入栈)：将元素添加到栈顶
- **pop**(出栈)：移除栈顶元素
- **peek**(获取栈顶元素)：不删除，只访问
- **isEmpty**(判断是否为空)

### **时间复杂度**

- 入栈、出栈、访问栈顶：O(1)

### **适用场景**

- **递归调用**（系统调用栈）
- **表达式求值**（如括号匹配、中缀转后缀）
- **深度优先搜索（DFS）**（如图遍历）

------

## **队列（Queue）**

队列是一种**先进先出（FIFO, First In First Out）\**的数据结构，元素只能从\**队尾入队**，从**队头出队**。

### **特殊队列**

- **双端队列（Deque）**：可以在两端插入和删除
- **循环队列（Circular Queue）**：解决普通队列的空间浪费问题
- **优先队列（Priority Queue）**：出队顺序由优先级决定，而非入队顺序

### **适用场景**

- **任务调度**（CPU 任务、线程池）
- **广度优先搜索（BFS）**
- **消息队列**（Kafka、RabbitMQ）

------

## **链表（Linked List）**

链表是一种**非连续存储**的线性数据结构，每个节点包含两个部分：

1. **数据域**（存储数据）
2. **指针域**（指向下一个节点）

### **常见类型**

- **单向链表**：每个节点只指向下一个节点
- **双向链表**：每个节点有**前后指针**
- **循环链表**：尾节点指向头节点，形成闭环

### **优缺点**

✅ **动态扩展**，插入和删除 O(1)（不涉及查找）
 ❌ **访问慢**，查找 O(n)

### **适用场景**

- **动态数据存储**（如内存管理）
- **频繁插入删除的操作**（如 LRU 缓存）

------

## **字典（Dictionary）**

字典是一种**键值对（key-value）\**存储的数据结构，类似于\**Map**。它的特点是：

- **无序存储**
- **快速查找（O(1)）**
- **动态扩展**

**常见实现方式**

- **基于哈希表（散列表）**：如 JavaScript 的 `Map`，Python 的 `dict`
- **基于红黑树**：如 C++ 的 `std::map`（实现为平衡二叉搜索树）

### **适用场景**

- **缓存系统（如 Redis）**
- **数据库索引**
- **配置存储**

------

## **散列表（Hash Table）**

散列表（哈希表）使用**哈希函数**将键映射到数组索引，以支持**O(1) 时间复杂度**的查找和插入。

### **主要问题**

- 哈希冲突（Hash Collision）
  - **开放地址法**（线性探测、二次探测）
  - **链地址法**（拉链法）

### **适用场景**

- **快速查找**（如 DNS 解析、编译器符号表）
- **去重操作**（如数据库索引）

------

## **树（Tree）**

树是一种**非线性**数据结构，由**节点（Node）\**组成，具有\**层级结构**，常见的树结构包括：

- **二叉树（Binary Tree）**
- **二叉搜索树（BST）**
- **平衡二叉树（AVL、红黑树）**
- **B 树 / B+ 树**（数据库索引）

### **适用场景**

- **文件系统**（目录结构）
- **数据库索引（B+ 树）**
- **编译器语法分析（语法树）**
- **AI 领域的搜索（决策树、搜索树）**

------

## **图（Graph）**

图由**顶点（Vertex）\**和\**边（Edge）\**组成，可用于表示\**网络关系**。

### **图的存储**

- **邻接矩阵**（适合稠密图）
- **邻接表**（适合稀疏图）

### **图的遍历**

- **深度优先搜索（DFS）**
- **广度优先搜索（BFS）**

### **适用场景**

- **社交网络**（好友推荐）
- **地图导航**（最短路径）
- **电路分析**

------

## **堆（Heap）**

堆是一种**特殊的完全二叉树**，用于**优先级队列**，分为：

1. **最大堆（Max Heap）**：根节点是**最大值**
2. **最小堆（Min Heap）**：根节点是**最小值**

### **堆的基本操作**

- **插入（O(log n)）**
- **删除（O(log n)）**
- **获取堆顶（O(1)）**

### **适用场景**

- **优先队列（任务调度、Dijkstra 最短路径）**
- **堆排序（Heap Sort，O(n log n)）**
- **Top K 问题**（如搜索引擎排名）

------

## **总结**

| 数据结构 | 访问     | 插入     | 删除     | 适用场景               |
| -------- | -------- | -------- | -------- | ---------------------- |
| 数组     | O(1)     | O(n)     | O(n)     | 随机访问，少量插入删除 |
| 栈       | O(n)     | O(1)     | O(1)     | 递归、括号匹配、DFS    |
| 队列     | O(n)     | O(1)     | O(1)     | BFS、任务调度          |
| 链表     | O(n)     | O(1)     | O(1)     | 频繁插入删除           |
| 哈希表   | O(1)     | O(1)     | O(1)     | 快速查找、去重         |
| 堆       | O(n)     | O(log n) | O(log n) | 优先级队列             |
| 树       | O(log n) | O(log n) | O(log n) | 数据索引、搜索         |
| 图       | O(n)     | O(1)     | O(1)     | 地图、社交网络         |

堆是**优先级队列的基础**，在调度、路径规划等领域非常重要。如果你想深入学习堆的实现，如**二叉堆、斐波那契堆**等，可以继续探讨！ 🚀