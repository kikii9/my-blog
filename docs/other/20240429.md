# 20240429

## 一、BFC（Block Formatting Context）理解

BFC（块级格式化上下文）是CSS布局概念，影响元素布局及相互隔离。在BFC内：
- 浮动元素不会影响外部元素。
- BFC内部元素的margin不会折叠。
- 可用于清除浮动，包含浮动元素。
- 有助于实现自适应布局，如两栏布局。

## 二、JavaScript 数据类型

- **原始数据类型**：`undefined`, `null`, `boolean`, `number`, `string`, `symbol` (ES6引入), `bigint` (ES10引入)。
- **引用数据类型**：`object` (包括数组Array、函数Function、日期Date、正则表达式RegExp等)。

## 三、原型（Prototype）

原型是JavaScript中实现继承的主要机制。每个对象都有一个内置属性[[Prototype]]（通常通过`__proto__`访问，或使用标准的`Object.getPrototypeOf()`方法），指向其原型对象。原型链上的属性查找允许一个对象继承另一个对象的属性和方法。

## 四、`new`操作符

`new`操作符创建一个实例对象，过程包括：
1. 创建一个新的空对象。
2. 将新对象的`__proto__`指向构造函数的`prototype`。
3. 执行构造函数，给新对象添加属性和方法。
4. 如果构造函数返回非基本类型值，则返回该值；否则返回新创建的对象。

## 五、闭包

闭包（Closure）是函数式编程中的一个重要概念，它本质上是一种特性，使得一个函数可以访问并操作其自身作用域以外的变量，即使在其父函数已经执行完毕后仍然如此。

具体来说，闭包是由函数及其相关的引用环境组合而成的实体。引用环境保存了函数在其定义时所处的作用域中所有未被清除的外部变量的 bindings（绑定关系）。

闭包的作用主要包括：

1. **访问和修改外部作用域的变量**：闭包使得内部函数能够记住并访问其外部函数的局部变量，即使外部函数已经返回。
2. **实现私有变量**：通过闭包，可以创建只能由内部函数访问的变量，模拟面向对象语言中的私有成员，增强数据封装。
3. **实现模块化**：闭包可以帮助创建独立的模块，避免全局变量的污染，通过返回特定的函数来控制对内部状态的访问。
4. **函数柯里化**：利用闭包保持状态，可以将多参数函数转换为一系列单参数函数的链式调用，实现函数柯里化。
5. **实现迭代器和生成器**：闭包可以用来保存迭代的状态，从而创建迭代器或生成器函数。

关于闭包可能导致的内存泄漏问题，这通常发生在当闭包持续引用不再需要的大对象或集合时，如果这些引用没有被适时释放，就可能阻止垃圾回收器回收相关内存，从而造成内存泄漏。开发者需要谨慎管理闭包中的引用，特别是在长时间运行的应用中，确保不再使用的资源能够被及时释放。



## 七、`computed`与`watch`区别

- **computed**：
  - 支持缓存，计算属性值依赖的数据未变时，结果不会重新计算。
  - 更适合用于计算属性，即依赖其它数据且结果可被缓存的属性。
  
- **watch**：
  - 不具备缓存功能，每次依赖数据变化都会执行回调。
  - 支持异步操作，适用于执行副作用操作或复杂逻辑处理。

| 特性         | computed                               | watch                                      |
| ------------ | -------------------------------------- | ------------------------------------------ |
| **目的**     | 计算基于响应式依赖的值，可作为属性使用 | 监听数据变化，执行相应处理函数             |
| **缓存**     | 有，只在依赖变化时重新计算             | 无，每次监听数据变化时都会执行             |
| **异步支持** | 否，更适合同步计算                     | 是，适合执行异步操作如网络请求等           |
| **使用场景** | 衍生状态计算，频繁且结果可复用         | 数据变化后的副作用处理，复杂逻辑或异步操作 |
| **性能**     | 高，减少不必要的计算                   | 低，每次触发都会执行回调                   |

### computed 优势
- **高效性**：利用缓存机制避免重复计算，对于不变的依赖结果直接返回缓存值。
- **简洁性**：可以直接在模板中使用，如同普通属性，使模板更加清晰。

### watch 优势
- **灵活性**：支持执行异步操作，适用于处理副作用逻辑，如网络请求、DOM操作。
- **细致控制**：可以通过`immediate`选项立即触发回调，或`deep`选项深度监听对象内部变化。

### 总结
选择`computed`还是`watch`应依据具体需求：
- 如果你需要一个属性基于其他数据动态计算且结果会被多次使用，首选`computed`。
- 对于需要在数据变化时执行特定逻辑，尤其是涉及异步操作的场景，则应使用`watch`。

## 八、Vue性能优化

- **v-for key**：帮助Vue跟踪每个节点的身份，优化列表渲染性能，避免不必要的DOM操作。
- **避免使用index作为key**：当列表项位置频繁变动时，使用唯一标识（如数据库id）作为key更安全。
- **懒加载**：图片和组件的延迟加载，提升首屏加载速度。
- **Webpack优化**：Tree Shaking、代码分割、懒加载、压缩混淆等。
- **Keep-alive**：缓存组件，减少重复渲染。

## 九、Vue生命周期

Vue实例从创建到销毁经历了多个阶段：
- **BeforeCreate**：实例刚被创建，属性观测、事件配置都未完成。
- **Created**：实例已经创建完成，属性绑定、事件监听完成，但DOM还未生成。
- **BeforeMount**：挂载前，即将开始渲染DOM。
- **Mounted**：实例挂载到DOM上，渲染完成，可以访问到DOM元素。
- **BeforeUpdate**：数据更新前。
- **Updated**：数据更新后，DOM重新渲染完成。
- **Activated**：（仅限keep-alive组件）组件被激活。
- **Deactivated**：（仅限keep-alive组件）组件被停用。
- **BeforeDestroy**：实例销毁前，可执行清理操作。
- **Destroyed**：实例已被销毁，所有子实例和监听器也被移除。

## 十、Vue组件通信

- **Props & Emit**：父组件向子组件传递数据。
- **Vuex**：状态管理模式，用于跨组件共享状态。
- **Event Bus**：一个全局的事件中心，用于非父子组件间的通信。
- **Provide / Inject**：祖先组件向下提供变量，子孙组件注入使用。
- **$refs**：直接访问子组件实例或DOM元素。

## 十一、开发工具

- **IDE/编辑器**：VSCode, WebStorm, Sublime Text等。
- **Vue CLI**：快速搭建Vue项目的脚手架工具。
- **Vue DevTools**：浏览器插件，方便调试Vue应用。
- **Webpack**：模块打包工具，用于项目构建和优化。
- **Git**：版本控制系统。

## 十二、Vue.data为什么是函数

Vue实例的`data`必须是一个函数，以便每个组件实例都能维护一份独立的数据副本。这样在创建新的组件实例时，Vue会调用这个函数，为每个实例返回一个初始数据对象，保证数据的独立性。

## 十三、`v-if`与`v-show`的区别

- **v-if**：条件渲染，根据条件决定是否渲染DOM元素，不满足条件时元素不会存在于DOM中，适合条件较少的切换。
- **v-show**：通过CSS的display属性切换元素的显示与隐藏，无论条件如何元素始终渲染并保留在DOM中，仅改变可见性，适合频繁切换。

## 十四、盒子模型

CSS盒子模型描述了元素在页面布局中占据空间的方式，分为两种：
- **W3C标准盒模型**（content-box）：总宽度=内容宽度+padding+border+margin。
- **IE盒模型**（border-box）：总宽度=设置的width（包含padding和border），更常用。

## 十五、JS脚本异步加载

- **defer**：脚本延迟到文档解析完成后再执行，但执行顺序按照脚本在文档中的顺序。
- **async**：脚本异步加载，加载完成后立即执行，不保证执行顺序。
- 动态创建`<script>`标签，通过其`onload`或`onreadystatechange`事件处理程序控制执行时机。

JavaScript脚本异步加载是提高网页加载速度和性能的关键技术之一，它允许脚本文件在后台加载，不阻塞页面的渲染和其他资源的加载。以下是几种常见的JavaScript脚本异步加载方法：

### 1. 使用`async`属性

- **特点**：`async`属性使得脚本异步加载，并且在下载完成后立即执行，不保证执行顺序。
- **语法**：`<script src="your-script.js" async></script>`
- **适用场景**：适用于不影响页面初始渲染或相互独立的脚本。

### 2. 使用`defer`属性

- **特点**：`defer`属性也使得脚本异步加载，但所有带有`defer`属性的脚本会按照在HTML中出现的顺序在DOM解析完成后，DOMContentLoaded事件触发之前执行。
- **语法**：`<script src="your-script.js" defer></script>`
- **适用场景**：适用于需要保持执行顺序，但又不想阻塞渲染的脚本。

### 3. 动态创建`<script>`标签

- **特点**：在JavaScript中动态创建`<script>`标签并插入到DOM中，可以控制加载和执行时机。
- **示例**：
  ```javascript
  var script = document.createElement('script');
  script.src = 'your-script.js';
  script.onload = function() {
    // 脚本加载完成后的回调
  };
  document.head.appendChild(script);
  ```
- **适用场景**：需要更精细控制脚本加载和执行流程时使用。

### 4. 使用`fetch`或`XMLHttpRequest`

- **特点**：通过这两个API可以异步请求脚本内容，然后通过`eval`或创建新的`<script>`标签执行。
- **注意**：直接使用`eval`是不推荐的，因为它有安全风险和性能问题。

### 5. 模块加载器和打包工具

- **特点**：如RequireJS、ES6模块导入（`import`）、Webpack等，提供了异步模块加载机制。
- **适用场景**：大型项目中，需要模块化管理和按需加载时。

### 总结

选择合适的异步加载策略取决于你的具体需求，如页面加载性能、脚本之间的依赖关系、执行顺序等。合理运用这些技术可以显著提升用户体验，减少页面加载时间和提高应用的响应速度。

## 十六、闭包理解

闭包是指有权访问另一个函数作用域中变量的函数，创建机制是函数嵌套。闭包可以读取外层函数的局部变量，即使外层函数已经执行完毕。它常用于设计私有变量、实现模块化或创建函数工厂等场景。

## 十七、浏览器从URL到页面渲染过程

1. **解析URL**：确定协议、主机、路径。
2. **DNS解析**：将域名转换为IP地址。
3. **建立TCP连接**：三次握手建立连接。
4. **发送HTTP请求**：包括请求行、请求头、请求体。
5. **服务器处理请求**：处理后返回HTTP响应。
6. **浏览器接收响应**：渲染引擎解析HTML、CSS、执行JavaScript。
7. **构建DOM树**：将HTML解析为DOM树。
8. **计算样式**：CSSOM树与DOM树结合生成渲染树。
9. **布局与绘制**：计算元素几何位置，绘制像素到屏幕。

## 十八、Vue computed与watch实现原理

- **Computed**：基于getter/setter，依赖收集与缓存机制。getter执行时追踪依赖，只有当依赖发生变化时才重新计算。
- **Watch**：基于事件监听，更灵活，支持异步操作。通过监听特定数据的变化来执行回调函数，可以手动控制执行时机。

## 十九、Vue nextTick的作用与实现原理

- **作用**：在下次DOM更新循环结束之后执行延迟回调。常用于数据变化后立即获取更新后的DOM状态或避免同步更新导致的错误。
- **实现原理**：Vue内部使用微任务（MutationObserver或Promise）来调度nextTick队列，确保回调在DOM更新后执行。

## 二十、Vue虚拟DOM与Diff算法

- **虚拟DOM**：轻量级的DOM树表示，用于提高DOM操作性能。它是一个JavaScript对象树，映射实际DOM结构。
- **Diff算法**：Vue在虚拟DOM更新时，通过高效的算法比较新旧虚拟DOM树差异，最小化实际DOM操作。主要策略包括：
  - 树的遍历比较，从上至下，从左至右；
  - 对象复用，如果节点类型相同且key值不变，则复用现有节点；
  - 复杂情况递归处理子节点差异。

## 二十一、项目难点与解决方案

由于具体项目和场景差异较大，这里不提供特定案例，但解决问题的一般步骤包括：
1. **明确问题**：详细分析问题现象，定位问题根源。
2. **研究资料**：查阅官方文档、社区讨论、相关文章等，寻找解决方案或灵感。
3. **原型测试**：小范围尝试解决方案，快速验证可行性。
4. **迭代优化**：根据测试反馈，不断调整优化方案直至问题解决。
5. **文档记录**：总结经验，编写文档或笔记，便于团队共享和未来参考。

## 二十二、webpack优化

Webpack 打包优化是前端开发中的重要环节，旨在提升构建速度、减小输出文件体积并改善应用程序的加载性能。以下是一些关键的Webpack优化策略：

### 1. **升级依赖**
- **更新Webpack及其插件**：确保使用最新版本的Webpack、Loader和插件，因为新版本通常包含性能改进。
- **更新Node.js和npm/yarn**：更新Node.js版本和包管理器可以提升构建效率。

### 2. **代码分割**
- **动态导入（`import()`**：按需加载代码，仅当需要时才加载模块。
- **SplitChunksPlugin**：自动拆分公共模块，减少重复代码，优化加载时间。

### 3. **Loader优化**
- **精简Loader使用**：只在必要时使用Loader，避免不必要的转换。
- **配置`exclude/include`**：精确控制哪些文件应用Loader，避免对node_modules等目录的处理。

### 4. Tree Shaking
- **生产环境配置**：确保在生产环境下开启Tree Shaking，移除未使用的代码。
- **ES6模块**：确保依赖库支持Tree Shaking，使用ES6模块规范编写代码。

### 5. 缓存
- **持久化缓存**：利用Webpack的长期缓存机制，如Content Hash，确保文件名包含哈希值，以便浏览器可以缓存静态资源。
- **模块热替换（HMR, Hot Module Replacement）**：开发时减少页面刷新，加快调试速度。

### 6. 优化Source Map
- **生产环境**：关闭生产环境的Source Map以减小文件体积，除非需要时再开启。
- **外部Source Map**：如果需要调试，可以考虑使用外部Source Map，分离出单独的.map文件。

### 7. 压缩代码
- **UglifyJsPlugin/TerserPlugin**：在生产环境中使用代码压缩插件减小文件大小。
- **Gzip压缩**：服务器端开启Gzip压缩，进一步减少传输体积。

### 8. 分析工具
- **Speed Measure Plugin**：分析Webpack构建过程，找出耗时的Loader或Plugin。
- **Webpack Bundle Analyzer**：可视化输出包内容，帮助识别体积大的模块。

### 9. DLL（Dynamic Link Library）
- **DLL Plugin/DLL Reference Plugin**：将不常变更的第三方库预先打包，减少每次构建的负担。

### 10. 配置优化
- **去除无用插件**：区分开发和生产环境配置，避免生产环境打包不必要的开发工具。
- **环境变量**：利用环境变量控制不同环境下的配置，如devtool设置。

### 11. 预编译
- **Babel缓存**：开启Babel缓存（`.babelrc`中的`cacheDirectory`），加速转译过程。

### 12. 静态资源处理
- **图片和字体资源**：使用Webpack的加载器（如`url-loader`、`file-loader`）优化图片和字体资源的处理。

### 13. 自动化优化
- **Webpack自动配置工具**：利用如`webpack-merge`、`webpack-chain`等工具或脚本自动化配置优化。

综合应用以上策略，可以显著提升Webpack的打包速度和输出文件的效率，进而优化应用的整体性能。