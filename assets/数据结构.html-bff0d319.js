import{_ as t,o as r,c as n,a as s}from"./app-1f20ff92.js";const a={},o=s('<h1 id="数据结构简介" tabindex="-1"><a class="header-anchor" href="#数据结构简介" aria-hidden="true">#</a> 数据结构简介</h1><h2 id="数组-array" tabindex="-1"><a class="header-anchor" href="#数组-array" aria-hidden="true">#</a> <strong>数组（Array）</strong></h2><p>数组是一种线性数据结构，它使用<strong>连续的内存空间</strong>存储<strong>相同类型</strong>的元素，并通过索引（下标）访问元素。数组的特点：</p><ul><li><strong>随机访问</strong>：通过索引可以直接访问任意元素，时间复杂度为 O(1)。</li><li><strong>固定大小</strong>：一般初始化时需指定大小，不能动态扩展（除非使用动态数组）。</li><li><strong>插入和删除</strong>：需要移动元素，时间复杂度最差情况为 O(n)。</li></ul><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> <strong>适用场景</strong></h3><ul><li>需要频繁随机访问的场景，如数据库缓存、二维表存储等。</li></ul><hr><h2 id="栈-stack" tabindex="-1"><a class="header-anchor" href="#栈-stack" aria-hidden="true">#</a> <strong>栈（Stack）</strong></h2><p>栈是一种**后进先出（LIFO, Last In First Out）<strong>的数据结构，只允许在</strong>一端（栈顶）**进行插入和删除操作。</p><h3 id="栈的操作" tabindex="-1"><a class="header-anchor" href="#栈的操作" aria-hidden="true">#</a> <strong>栈的操作</strong></h3><ul><li><strong>push</strong>(入栈)：将元素添加到栈顶</li><li><strong>pop</strong>(出栈)：移除栈顶元素</li><li><strong>peek</strong>(获取栈顶元素)：不删除，只访问</li><li><strong>isEmpty</strong>(判断是否为空)</li></ul><h3 id="时间复杂度" tabindex="-1"><a class="header-anchor" href="#时间复杂度" aria-hidden="true">#</a> <strong>时间复杂度</strong></h3><ul><li>入栈、出栈、访问栈顶：O(1)</li></ul><h3 id="适用场景-1" tabindex="-1"><a class="header-anchor" href="#适用场景-1" aria-hidden="true">#</a> <strong>适用场景</strong></h3><ul><li><strong>递归调用</strong>（系统调用栈）</li><li><strong>表达式求值</strong>（如括号匹配、中缀转后缀）</li><li><strong>深度优先搜索（DFS）</strong>（如图遍历）</li></ul><hr><h2 id="队列-queue" tabindex="-1"><a class="header-anchor" href="#队列-queue" aria-hidden="true">#</a> <strong>队列（Queue）</strong></h2><p>队列是一种<strong>先进先出（FIFO, First In First Out）*<em>的数据结构，元素只能从*<em>队尾入队</em></em>，从</strong>队头出队**。</p><h3 id="特殊队列" tabindex="-1"><a class="header-anchor" href="#特殊队列" aria-hidden="true">#</a> <strong>特殊队列</strong></h3><ul><li><strong>双端队列（Deque）</strong>：可以在两端插入和删除</li><li><strong>循环队列（Circular Queue）</strong>：解决普通队列的空间浪费问题</li><li><strong>优先队列（Priority Queue）</strong>：出队顺序由优先级决定，而非入队顺序</li></ul><h3 id="适用场景-2" tabindex="-1"><a class="header-anchor" href="#适用场景-2" aria-hidden="true">#</a> <strong>适用场景</strong></h3><ul><li><strong>任务调度</strong>（CPU 任务、线程池）</li><li><strong>广度优先搜索（BFS）</strong></li><li><strong>消息队列</strong>（Kafka、RabbitMQ）</li></ul><hr><h2 id="链表-linked-list" tabindex="-1"><a class="header-anchor" href="#链表-linked-list" aria-hidden="true">#</a> <strong>链表（Linked List）</strong></h2><p>链表是一种<strong>非连续存储</strong>的线性数据结构，每个节点包含两个部分：</p><ol><li><strong>数据域</strong>（存储数据）</li><li><strong>指针域</strong>（指向下一个节点）</li></ol><h3 id="常见类型" tabindex="-1"><a class="header-anchor" href="#常见类型" aria-hidden="true">#</a> <strong>常见类型</strong></h3><ul><li><strong>单向链表</strong>：每个节点只指向下一个节点</li><li><strong>双向链表</strong>：每个节点有<strong>前后指针</strong></li><li><strong>循环链表</strong>：尾节点指向头节点，形成闭环</li></ul><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> <strong>优缺点</strong></h3><p>✅ <strong>动态扩展</strong>，插入和删除 O(1)（不涉及查找） ❌ <strong>访问慢</strong>，查找 O(n)</p><h3 id="适用场景-3" tabindex="-1"><a class="header-anchor" href="#适用场景-3" aria-hidden="true">#</a> <strong>适用场景</strong></h3><ul><li><strong>动态数据存储</strong>（如内存管理）</li><li><strong>频繁插入删除的操作</strong>（如 LRU 缓存）</li></ul><hr><h2 id="字典-dictionary" tabindex="-1"><a class="header-anchor" href="#字典-dictionary" aria-hidden="true">#</a> <strong>字典（Dictionary）</strong></h2><p>字典是一种**键值对（key-value）*<em>存储的数据结构，类似于*<em>Map</em></em>。它的特点是：</p><ul><li><strong>无序存储</strong></li><li><strong>快速查找（O(1)）</strong></li><li><strong>动态扩展</strong></li></ul><p><strong>常见实现方式</strong></p><ul><li><strong>基于哈希表（散列表）</strong>：如 JavaScript 的 <code>Map</code>，Python 的 <code>dict</code></li><li><strong>基于红黑树</strong>：如 C++ 的 <code>std::map</code>（实现为平衡二叉搜索树）</li></ul><h3 id="适用场景-4" tabindex="-1"><a class="header-anchor" href="#适用场景-4" aria-hidden="true">#</a> <strong>适用场景</strong></h3><ul><li><strong>缓存系统（如 Redis）</strong></li><li><strong>数据库索引</strong></li><li><strong>配置存储</strong></li></ul><hr><h2 id="散列表-hash-table" tabindex="-1"><a class="header-anchor" href="#散列表-hash-table" aria-hidden="true">#</a> <strong>散列表（Hash Table）</strong></h2><p>散列表（哈希表）使用<strong>哈希函数</strong>将键映射到数组索引，以支持<strong>O(1) 时间复杂度</strong>的查找和插入。</p><h3 id="主要问题" tabindex="-1"><a class="header-anchor" href="#主要问题" aria-hidden="true">#</a> <strong>主要问题</strong></h3><ul><li>哈希冲突（Hash Collision） <ul><li><strong>开放地址法</strong>（线性探测、二次探测）</li><li><strong>链地址法</strong>（拉链法）</li></ul></li></ul><h3 id="适用场景-5" tabindex="-1"><a class="header-anchor" href="#适用场景-5" aria-hidden="true">#</a> <strong>适用场景</strong></h3><ul><li><strong>快速查找</strong>（如 DNS 解析、编译器符号表）</li><li><strong>去重操作</strong>（如数据库索引）</li></ul><hr><h2 id="树-tree" tabindex="-1"><a class="header-anchor" href="#树-tree" aria-hidden="true">#</a> <strong>树（Tree）</strong></h2><p>树是一种<strong>非线性</strong>数据结构，由**节点（Node）*<em>组成，具有*<em>层级结构</em></em>，常见的树结构包括：</p><ul><li><strong>二叉树（Binary Tree）</strong></li><li><strong>二叉搜索树（BST）</strong></li><li><strong>平衡二叉树（AVL、红黑树）</strong></li><li><strong>B 树 / B+ 树</strong>（数据库索引）</li></ul><h3 id="适用场景-6" tabindex="-1"><a class="header-anchor" href="#适用场景-6" aria-hidden="true">#</a> <strong>适用场景</strong></h3><ul><li><strong>文件系统</strong>（目录结构）</li><li><strong>数据库索引（B+ 树）</strong></li><li><strong>编译器语法分析（语法树）</strong></li><li><strong>AI 领域的搜索（决策树、搜索树）</strong></li></ul><hr><h2 id="图-graph" tabindex="-1"><a class="header-anchor" href="#图-graph" aria-hidden="true">#</a> <strong>图（Graph）</strong></h2><p>图由**顶点（Vertex）**和**边（Edge）*<em>组成，可用于表示*<em>网络关系</em></em>。</p><h3 id="图的存储" tabindex="-1"><a class="header-anchor" href="#图的存储" aria-hidden="true">#</a> <strong>图的存储</strong></h3><ul><li><strong>邻接矩阵</strong>（适合稠密图）</li><li><strong>邻接表</strong>（适合稀疏图）</li></ul><h3 id="图的遍历" tabindex="-1"><a class="header-anchor" href="#图的遍历" aria-hidden="true">#</a> <strong>图的遍历</strong></h3><ul><li><strong>深度优先搜索（DFS）</strong></li><li><strong>广度优先搜索（BFS）</strong></li></ul><h3 id="适用场景-7" tabindex="-1"><a class="header-anchor" href="#适用场景-7" aria-hidden="true">#</a> <strong>适用场景</strong></h3><ul><li><strong>社交网络</strong>（好友推荐）</li><li><strong>地图导航</strong>（最短路径）</li><li><strong>电路分析</strong></li></ul><hr><h2 id="堆-heap" tabindex="-1"><a class="header-anchor" href="#堆-heap" aria-hidden="true">#</a> <strong>堆（Heap）</strong></h2><p>堆是一种<strong>特殊的完全二叉树</strong>，用于<strong>优先级队列</strong>，分为：</p><ol><li><strong>最大堆（Max Heap）</strong>：根节点是<strong>最大值</strong></li><li><strong>最小堆（Min Heap）</strong>：根节点是<strong>最小值</strong></li></ol><h3 id="堆的基本操作" tabindex="-1"><a class="header-anchor" href="#堆的基本操作" aria-hidden="true">#</a> <strong>堆的基本操作</strong></h3><ul><li><strong>插入（O(log n)）</strong></li><li><strong>删除（O(log n)）</strong></li><li><strong>获取堆顶（O(1)）</strong></li></ul><h3 id="适用场景-8" tabindex="-1"><a class="header-anchor" href="#适用场景-8" aria-hidden="true">#</a> <strong>适用场景</strong></h3><ul><li><strong>优先队列（任务调度、Dijkstra 最短路径）</strong></li><li><strong>堆排序（Heap Sort，O(n log n)）</strong></li><li><strong>Top K 问题</strong>（如搜索引擎排名）</li></ul><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> <strong>总结</strong></h2><table><thead><tr><th>数据结构</th><th>访问</th><th>插入</th><th>删除</th><th>适用场景</th></tr></thead><tbody><tr><td>数组</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>随机访问，少量插入删除</td></tr><tr><td>栈</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>递归、括号匹配、DFS</td></tr><tr><td>队列</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>BFS、任务调度</td></tr><tr><td>链表</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>频繁插入删除</td></tr><tr><td>哈希表</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>快速查找、去重</td></tr><tr><td>堆</td><td>O(n)</td><td>O(log n)</td><td>O(log n)</td><td>优先级队列</td></tr><tr><td>树</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td><td>数据索引、搜索</td></tr><tr><td>图</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>地图、社交网络</td></tr></tbody></table><p>堆是<strong>优先级队列的基础</strong>，在调度、路径规划等领域非常重要。如果你想深入学习堆的实现，如<strong>二叉堆、斐波那契堆</strong>等，可以继续探讨！ 🚀</p>',74),i=[o];function e(d,l){return r(),n("div",null,i)}const h=t(a,[["render",e],["__file","数据结构.html.vue"]]);export{h as default};
